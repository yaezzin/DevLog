## 연속 메모리 할당의 문제점?

1. 외부 단편화
2. 물리 메모리보다 큰 프로세스를 실행할 수 없음

## 가상 메모리

> 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
* 크게 ```페이징```과 ```세그멘테이션```이 있으나, 현대 운영체제는 대부분 페이징 기법을 다룸

## 페이징

연속 메모리 할당 방식에서 외부 단편화가 생긴 이유는 **각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문**   
따라서 메모리와 프로세스를 일정한 단위(ex. 10MB)로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 외부단편화는 발생 X → ```페이징```

<img width="500" alt="스크린샷 2023-06-27 오전 11 24 53" src="https://github.com/yaezzin/TIL/assets/97823928/b2b95883-5b84-42c8-a2bb-bbf3d816a6b8">

```페이징```은 프로세스의 논리주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기로 자른 뒤 페이지를 프레임에 할당하는 **가상 메모리 관리 기법**
* 페이징을 사용하면 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없어짐
* 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨두어 물리 메모리보다 더 큰 프로세스를 실행할 수 있음

## 페이지 테이블 

하지만 프로세스가 메모리에 불연속으로 배치되어있다면 CPU입장에서는 다음에 실행할 명령어 위치를 알기 어려워짐  → ```페이지 테이블``` 이용
* 프로세스가 물리 주소(실제 메모리 내의 주소)에 불연속 적으로 배치되더라도 논리 주소(CPU가 바라보는 주소)에는 연속적으로 베치되도록 함
* 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행
* 프로세스마다 각자 프로세스 테이블을 가지고 있고, 각 프로세스의 페이지 테이블은 메모리에 적재됨
* CPU 내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴
  * 하지만 페이지 테이블을 메모리에 두게되면 메모리 접근 시간이 2배로 늘어남
  * 메모리에 있는 페이지 테이블을 보기위해 + 그렇게 알게된 프레임에 접근하기 위해 = 총 2번
  * 따라서 CPU 곁에 TLB라는 페이지 테이블의 캐시메모리를 두어 페이지 테이블의 일부 내용(최근에 사용된 페이지 위주)을 저장

## 페이지 테이블 엔트리

페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라고 함
* 페이지 번호, 프레임 번호, 유효 비트, 보호비트, 참조 비트, 수정 비트 등이 있음

### 유효 비트

> 현재 해당 페이지에 접근 가능한지 여부를 나타내는 비트

* 유효비트는 현재 페이지가 메모리에 적재되어있는지 아니면 스왑아웃으로 인해 보조기억장치에 있는지 알려주는 비트
* 즉 페이지가 메모리에 적재되어있다면 유효비트가 1, 그렇지 않으면 유효비트가 0
  * 만약 유효비트가 0인 페이지에 접근하려하면 ```페이지 폴트```라는 예외가 발생

### 보호 비트

> 페이지 보호 기능을 위한 비트

* 해당 페이지가 읽고 쓰기가 모두 가능한지, 아니면 읽기만 가능한 페이지인지를 나타냄
* 비트가 0일 경우 읽기만 가능, 1일 경우 읽고 쓰기가 모두 가능
* 프로세스를 이루는 요소 중 코드 영역은 읽기 전용인데, 이러한 읽기 전용 페이지에 쓰기를 시도하면 운영체제가 이를 막아줌

### 참조 비트

> CPU가 해당 페이지에 접근한 적있는지 여부를 나타내는 비트

* 적재 이후 CPU가 읽거나 쓴적이 있으면 1로, 그렇지 않으면 0으로 세팅

### 수정 비트

> 해당 페이지에 데이터를 쓴적이 있는지 수정여부를 나태는 비트

* 이 비트가 1이면 변경된적이 있는 페이지, 0이면 변경된적이 없는 페이지를 나타냄
* 수정비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지, 할 필요가 없는지 판단하기 위해 존재
  * 만약 CPU가 한번도 접근하지 않았거나 읽기만 한 페이지의 경우(수정 비트가 0일경우) 보조 기억장치에 저장된 내용과 메모리에 저장된 내용은 서로 같은 값을 가지고 있음
  * 따라서 한번도 수정된 적이 없는 페이지가 스왑아웃될 경우 아무런 추가작업 없이 새로 적재된 페이지로 덮어쓰기만 하면 됨
  * CPU가 쓰기 작업을 수행한 페이지의 경우 보조기억장치에 저장된 페이지dml 내용과 메모리에 저장된 내용은 서로 다른 값을 가지기 때문에 스왑 아웃될 경우 변경된 값을 보조 기억장치에 기록하는 작업이 추가되어야 함

## 내부 단편화
<img width="230" alt="스크린샷 2023-06-27 오전 11 24 53" src="https://github.com/yaezzin/TIL/assets/97823928/e48f454d-387f-46d1-b7b2-723659b647f8">

페이징은 외부 단편화 문제는 해결할 수 있으나 내부 단편화 문제를 야기 할 수 있음
* 페이징은 논리 주소 공간을 페이지라는 일정한 크기로 자르는데, 모든 프로세스가 페이지의 크기에 딱 맞게 잘리지 않음
* 페이지보다 더 작은 프로세스를 실행하거나, 하나의 페이지를 넘어선 프로세스를 실행하면 내부단편화가 발생할 수 있음
