## 교착상태 DeadLock

> 두 개 이상의 프로세스 또는 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태  
> : ```무한히 다음 자원을 기다리는 상태```

프로세스A와 B가 자원 1, 2를 얻어야 한다고 가정하면
* T1 : 프로세스1이 자원 1을 얻음 & 프로세스2가 자원 2를 얻음
* T2 : 프로세스1은 자원 2를 기다림 & 프로세스2은 자원 1를 기다림
* 현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐 → ```DeadLock```

## 교착상태 발생 조건

#### 1. 상호 배제

자원은 한번에 한 프로세스만 사용할 수 있음

#### 2. 점유와 대기

최소 하나의 자원을 점유하면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위한 프로세스가 존재함

#### 3. 비선점

다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

#### 4. 원형대기

프로세스의 집합에서 순환형태로 자원을 대기하고 있어야 함

## 해결방법

### 1. 예방

> 교착 상태 발생 조건 중 하나를 제거하면서 해결하는 방법 → 자원 낭비가 심함

```상호배제를 부정```
* 모든 자원을 공유 가능하게 만들기 → 현실적으로 불가능
 
```점유와 대기 부정```
* 프로세스 실행 전 모든 자원을 할당
* 한 프로세스에 필요한 자원들을 몰아주고, 그 다음에 다른 프로세스에 몰아주는 방식

```비선점 부정```
* 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원을 반납

```원형대기 부정```
* 자원에 고유번호 할당 후 순서대로 자원을 할당
  * 시스템 내에 존재하는 수많은 자원에 번호를 붙이는 것은 불가능
  * 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 확용률이 떨어질 수 있음

### 2. 회피

> 교착 상태 발생 시 피해나가는 방법

```은행원 알고리즘```

* 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있는지 검사하여 교착 상태를 회피하는 방법
* 안정 상태면 자원을 할당하고, 불안정 상태면 다른 프로세스들이 자원을 해지할 떄까지 대기


### 3. 탐지 + 회복

> 교착 상태를 검출하고 사후에 조치하는 방식

```프로세스 종료```

* 교착 상태의 프로세스를 모두 중지하거나, 교착 상태가 제거될 떄까지 하나씩 프로세스를 중지하는 방식
* 간단한 방법이나, 프로세스 작업 내역을 잃을 수도 있음

```자원 선점```

* 교착 상태가 해결될 떄까지 한 프로세스씩 자원을 몰아주는 방식
* 우선순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점
