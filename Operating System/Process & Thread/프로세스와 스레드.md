## 스레드

#### 프로그램, 프로세스, 스레드

```프로그램```은 어떤 데이터로 어떤 작업을 할 것인지 절차를 적어 놓은 파일이다.   
→  이 프로그램을 메모리에 올려 실행 상태가 되면 ```프로세스```가 된다.  
→  ```스레드```는 **프로세스 내에서 실행되는 여러 흐름의 단위**를 의미한다.

#### 프로세스 vs 스레드

<img width="500" alt="스크린샷 2023-06-26 오전 10 13 36" src="https://github.com/yaezzin/TIL/assets/97823928/ccfab07a-692d-4981-8611-517a5219a221">

* 운영체제는 프로세스마다 독립된 메모리 영역을 Code/Data/Stack/Heap의 형식으로 할당한다. 
* 각각 독립된 메모리 영역을 할당해주기 때문에 **프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.**  

<img width="500" alt="스크린샷 2023-06-26 오전 10 13 36" src="https://github.com/yaezzin/TIL/assets/97823928/fa2f5144-090c-4c43-85df-6365a093a1c7">

* 스레드는 프로세스 내에서 스택만 할당받고, Code, Data, Heap 영역은 각 스레드가 공유한다.
* 스레드는 프로세스 내의 실행 흐름이기 때문에 같은 프로세스 내 스레드끼리 자원(Heap 등)을 공유하며 실행된다.
  * 스레드는 공유하는 자원인 Heap 영역에 있는 변수를 수정할 수 있다. (서로 읽고 쓸 수 있음)
* 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC)을 사용해야 하나, 스레드의 경우 같은 힙 공간을 공유하기 때문에 통신이 필요 없다.

👉 **프로세스는 기본적으로 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유한다.**

## 멀티 프로세싱과 멀티 스레딩

### 멀티 프로세싱

> 여러 개의 독립적인 프로세스를 동시에 실행하는 방식

#### 장점

* 독립된 메모리 공간을 가지고 실행되므로, 프로세스가 충돌하거나 오류가 발생해도 다른 프로세스에 영향을 주지 않는다.
* 여러 개의 프로세스를 동시에 실행할 수 있으므로, CPU 코어가 여러개인 시스템에서 병렬 처리가 가능하다.

#### 단점

* 독립된 메모리 공간과 자원을 할당 받아 사용하기 때문에, 상대적으로 더 많은 메모리와 자원을 소비하며, 상태 공유나 데이터 공유가 어렵다.
* 프로세스 간의 통신을 위해 IPC 메커니즘을 사용해야하는데, 이는 데이터 전달과 동기화를 위해 복잡한 과정을 거치게 한다.
* 각 프로세스는 독립적으로 시작되고 종료되어야 하기때문에 프로세스 간의 전환(ex. 문맥교환)에는 시간 및 비용이 소요된다.

### 멀티 스레딩

> 하나의 프로세스 내에서 여러 개의 스레드를 생성하여 동시에 실행하는 방식

#### 장점

* 멀티 스레딩은 스레드들이 동일한 주소 공간을 공유하기 때문에, 데이터 및 자원을 간단하게 공유할 수 있다. (스레드간 통신 비용이 적음) 
  * 스레드는 Stack 영역을 제외한 모든 메모리를 공유
  * 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠름
* 여러 작업을 동시에 처리할 수 있으므로, 한 스레드가 작업을 처리하는 동안 다른 스레드가 블록되는 상황을 피할 수 있다.

#### 단점

* 스레드들이 공유 자원에 동시에 접근할 수 있기 때문에, 동기화에 주의가 필요하다.
* 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있다.

## IPC (Inter-Process Communication)

> 프로세스 간의 자원을 공유하고 데이터를 주고 받는것

* 프로세스끼리는 완전히 독립된 실행 객체이므로 기본적으로 자원을 공유하지 않지만, 충분히 자원을 공유하고 데이터를 주고받을 수 있다.
* 이때 커널 영역에서 제공하는 IPC라는 내부 프로세스간 통신을 통해 프로세스 간의 통신이 가능해진다.
* IPC는 파이프, 소켓, 공유 메모리 등의 방법으로 이루어진다.

#### 1. 공유 메모리

프로세스들이 공유할 수 있는 메모리 영역을 ```공유 메모리```라고 한다.
* 만약 공유 메모리 영역 내에 name이라는 전역 변수가 있다 가정하고 프로세스 A가 name에 값을 저장한 뒤, B가 name변수 값을 읽어들인다면 두 프로세스는 전역 변수 name을 통해 서로 값을 주고받았다고 할 수 있다.
* 공유 메모리는 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 모든 IPC중에서 가장 빠르게 작동한다.
* 하지만 메시지 전달 방식이 아니기에 데이터를 읽어야하는 시점을 알 수 없다.


#### 2. 파이프

* 파이프를 통해 두 개의 프로세스를 연결하나, 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 데이터를 읽기만 할 수 있다.
  * 송/수신을 모두 하기 원한다면 두개의 파이프를 만들어야만 가능해진다. → 전이중 방식을 사용할거면 복잡한 구조를 가지게 됨 따라서 파이프를 쓸 필요가 없음
  * 한쪽 방향으로만 통신이 가능하여 ```Half-Duplex(반이중) 통신```이라고 한다.
* 간단하게 사용할 수 있다는 장점이 있지만, read()와 write()가 기본적으로 block mode로 작동되고, 버퍼가 작기 때문에 overflow가 될 가능성이 높다.


#### 3. 소켓

* 클라이언트-서버 통신에서 사용한다.
  * 서버단에서는 bind, listen, accept 진행해 소켓 연결을 위한 준비를 한다
  * 클라이언트 단에서는 connect을 통해 서버에 요청하고 연결이 수립 된 후에서는 socket에 send 함으로써 데이터를 주고 받는다.
  * 연결이 끝나면 반드시 close()로 clear 한다.
* 범용적인 IPC로써 양방향 통신이 가능하며, 패킷 단위로 주고 받음으로 직관적으로 이해하기 쉬운 코드를 만들 수 있다.

  
## 참고

* https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
* https://yaelimeee.tistory.com/56
