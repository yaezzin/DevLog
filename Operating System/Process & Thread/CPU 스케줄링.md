## CPU 스케줄링

다수의 프로세스가 CPU를 공유하여 실행될 때 어떤 순서로 CPU를 할당할지를 결정하는 것

#### 💬 CPU 집중 프로세스, 입출력 집중 프로세스 

두 프로세스가 동시에 대기 상태에 있다면 입출력 집중 프로세스에 먼저 CPU를 할당하는 것이 더 효율적이다.  
입출력 집충 프로세스는 CPU를 빠르게 쓰고 입출력 작업을 수행하기 떄문에 다른 프로세스가 오래 기다리지 않아도 되기 떄문이다.  
따라서 CPU 스케줄링은 프로세스의 우선순위, 실행 시간, 입출력 작업의 유무 등 다양한 요소를 고려하여 프로세스에게 적절한 CPU 할당을 결정하는 중요한 역할을 수행한다.

## 선점형 스케줄링

프로세스가 CPU를 점유하고 있더라도, 운영체제가 강제로 빼앗아 다른 프로세스에 할당할 수 있는 방식
* CPU 처리 시간이 긴 프로세스가 CPU 사용을 독점하는 것을 막을 수 있어 효율적인 운영이 가능하다.
* 하지만 잦은 문맥 교환으로 오버헤드가 발생한다.

## 비선점형 스케줄링

프로세스가 CPU를 점유하고 있다면, 실행을 완료할 때까지 이를 뺏을 수 없는 방식
* 필요한 문맥교환만 일어나기 때문에 오버헤드가 상대적으로 적으나, 프로세스의 배치에 따라 효율성 차이가 많이 난다.

## 1. FCFS

> 요청한 순서대로 CPU를 할당하는 방식

#### 예시 1

<img width="400" alt="스크린샷 2023-06-26 오후 1 11 09" src="https://github.com/yaezzin/TIL/assets/97823928/1e8c55ad-e58a-4d55-949e-04714ba56e90">

* 평균 대기시간 = (0 + 24 + 27)/3 = 17ms

#### 예시 2

<img width="380" alt="스크린샷 2023-06-26 오후 1 12 02" src="https://github.com/yaezzin/TIL/assets/97823928/840d166f-99cf-42ec-82eb-0da17de1f621"> 

* 평균 대기시간 = (0 + 3 + 6)/3 = 3ms

```문제점?```
* 위처럼 프로세스가 끝난 시간은 동일하나, CPU처리 시간이 긴 프로세스가 앞에 올 경우 대기 시간이 기다려지는 비효율성을 보인다 👉 ```콘보이 효과```

## 2. SJF (Shortest Job First)

> 가장 짧은 수행시간을 가진 프로세스에 먼저 CPU를 할당하는 방식

<img width="394" alt="스크린샷 2023-06-26 오후 1 14 40" src="https://github.com/yaezzin/TIL/assets/97823928/c752f9e6-1713-4ec0-a286-2b714c9acde3">

* 평균 대기시간 = (0 + 3 + 9 + 16)/4 = 7ms

<img width="391" alt="스크린샷 2023-06-26 오후 1 15 40" src="https://github.com/yaezzin/TIL/assets/97823928/0b9bd71c-ae37-4a3c-964f-d64c7a7efba4">

* 위의 프로세스를 FCFS로 수행했다면 (0 + 6 + 14 + 21)/4 = 10.25ms

```문제점?```
* SJF는 매우 효율적이나, 현실적으로 프로세스의 실행시간을 알기 위해서는 실제로 수행하여 측정하는 수 밖에 없다. 👉 오버헤드 큼

## 3. Round Robin

> 원모양으로 모든 프로세스가 돌아가며 CPU를 할당 받는 방식

<img width="464" alt="스크린샷 2023-06-26 오후 2 06 21" src="https://github.com/yaezzin/TIL/assets/97823928/ab2a0fed-e611-479a-80f9-3985219564ef">

* 평균 대기시간 = (4 + 7 + 10)/3 = 5.66ms
* Round-Robin 방식에서는 time quantum이 끝나면 CPU는 현재 프로세스를 대기상태로 보내고 다음 프로세스를 수행한다.
* 예제에서 P1이 0msec에 수행을 시작하여 종료되기 전에 time quantum(= 4ms) 시간이 끝나여 P2가 수행되는 모습을 볼 수 있다.
* 그리고 P2, P3는 time quantum이 끝나기전에 수행이 끝났고, 마지막 남은 P1은 다른 프로세스가 없으므로 time quantum이 끝나더라도 종료될 때까지 계속해서 수행하는 모습이다.

```문제점?```
* Round Robin방식은 time quantium 크기에 따라 효율성이 달라진다 👉 time quantium에 의존적
* 또한 time quantium 크기를 무한에 가깝게 설정하면 FCFS처럼, 반대로 0에 가깝게 설정하면 스위칭 오버헤드가 매우 증가하여 비효율적이 된다.

## 4. Prioirty

> 우선순위가 높은 프로세스에 먼저 CPU를 할당하는 방식

<img width="398" alt="스크린샷 2023-06-26 오후 1 31 31" src="https://github.com/yaezzin/TIL/assets/97823928/d9463b61-6b5e-44a3-a301-976686c89bff">

* 평균 대기시간 = (0 + 1 + 6 + 16 + 18)/5 = 8.2ms

```문제점?```
* Priority 스케쥴링은 어떤 프로세스가 CPU 점유를 오랫동안 하지 못하는 현상이 발생할 수 있는데, 👉 Starvation(기아)
* 실제 환경에서는 새로운 프로세스가 자주 준비큐에 들어오게 되고, 우선순위가 매우 낮은 프로세스는 준비 큐에서 무한정 대기하는 상태가 발생할 수 있다.
* 따라서 ```aging```을 통해 준비 큐에서 기다리는 동안 일정 시간이 지나면 우선순위를 기다리는 시간만큼 증가시켜줄 수 있다.

## 5. Multi Level Queue

> 프로세스는 성격에 따라 여러가지 그룹으로 나눌 수 있는데, 각 그룹에 따라 큐를 둘어 여러개의 큐를 사용하는 것

<img width="384" alt="스크린샷 2023-06-26 오후 2 10 58" src="https://github.com/yaezzin/TIL/assets/97823928/62829779-f7c8-4445-8d2f-9c3b1a14d1d2">

큐마다 우선순위를 정하거나, 다른 스케줄링 방식을 사용할 수 있다.
* ```System process```는 커널 수준의 중요한 작업이므로 우선순위가 높다.
* 위 그림에서 System process, Interactive process, Batch process 순으로 우선순위가 높은 순서이다.
* Batch 프로세스(ex. 컴파일러 = 일정량을 한 번에 처리하는 프로세스)는 운영체제의 개입이 매우 적으므로 우선순위가 가장 낮다.

## 6. Multilevel Feedback Queue

<img width="387" alt="스크린샷 2023-06-26 오후 2 16 25" src="https://github.com/yaezzin/TIL/assets/97823928/29d5b47a-55a7-473f-8733-d4a9fc2388df">

* Multi Level Queue의 경우 프로세스들이 큐 사이를 이동할 수 없기 때문에 우선순위가 낮은 프로세스는 계속 연기되어 기아현상이 발생할 수 있다.
따라서 이를 보완한 알고리즘이 MultiLevel Feeadback Queue이다.
* 모든 프로세스는 가장 위의 큐에서 CPU의 점유를 기다린다. 이 상태로 진행하다 해당 큐에서 기다리는 시간이 너무 오래 걸리면 아래의 큐로 프로세스를 옮긴다.
* 또한 너무 오래 기다리고 있는 프로세스가 있다면 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 방지할 수 있다.
* 따라서 CPU를 비교적 오래 사용하는 CPU 집중 프로세스들은 우선순위가 낮아지고, 적게 사용하는 입출력 집중 프로세스들은 우선순위가 높아진다. 

## 참고

* https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-6.-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81
