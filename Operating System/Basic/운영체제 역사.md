# 운영체제

## 1940-1950

### 초기의 컴퓨터

* 한 번에 한개의 프로그램을 실행
* 각 펀치 카드에 프로그램을 작성 후 순서대로 하나씩 읽어서 실행하는 방식
* 컴퓨터가 느려지는 등의 이유로 다시 실행하려면 WTF 

## 1950-1970

### 운영체제 등장

* 운영체제는 일반적으로 컴퓨터전원을 처음 켰을 때 시작하는 프로그램으로, 모든 후속 프로그램은 OS에 의해 시작됨
* 따라서 카드를 사람이 일일이 삽입하지 않고 컴퓨터 스스로 작동할 수 있는 방법이 개발

### 일괄처리

* 일괄 처리를 통해 한번에 하나의 프로그램을 받는 대신 컴퓨터가 일괄적으로 배치하여 하나를 완료하면 자동으로 다음을 시작할 수 있게 됨
* 그 당시에는 유일한 종류였던 컴퓨터와 달리 다양한 모델의 주변기기가 존재했고, 그 주변기기를 작동시키기 위해 각 주변기기의 세부 사항을 알고 코딩을 했어야 하나, 
* 운영체제가 장치 구동기라는 API를 제공하여 S/W와 H/W 사이의 중개자 역할을 함
* 예를 들어, 프린터에도 여러 종류가 있고 각 프린터마다 새로운 프로그램을 만드는 것을 비효율적이므로, 장치 구동기라는 API를 제공하여 표준화된 매커니즘을 통해 I/O와 대화

### 멀티태스킹

컴퓨터가 점점 빨라지면서 프린터와 같은 느린 기계들의 작동에 컴퓨터 프로세스가 차단되어 낭비되는 경우가 많아짐
* 따라서 최초로 멀티태스킹을 지원하는 OS를 탑재한 슈퍼 컴퓨터인 Atlas가 탄생
* 타를라스는 I/O가 끝날 때까지 기다리지 않고 프로그램을 절전 모드로 전환 후 대기 중인 프로그램을 실행
* 이후 I/O가 끝나면 그 다음 작업을 실행하도록 예약하는 방법을 사용하여 여러 개의 프로그램을 하나의 CPU에서 실행하도록 함

### 메모리 보호

하지만 하나의 컴퓨터에서 여러 프로그램을 동시에 실행하기엔 각각은 메모리가 필요할 것이고, 다른 프로그램으로 전환할 때 그 프로그램의 데이터를 잃어버리지 않았어야 했음.
* 따라서 각 프로그램마다 자체 메모리 블록을 생성하였음
* 하지만 이러한 방식은 프로그램 비순차 메모리 블록으로 할당될 수 있고, 한 프로그램에 수십개의 블록이 할당될 수 있기 때문에, 이러한 프로그램을 여러개 실행하면 프로그래머가 메모리를 추적하기 어려워짐
* 따라서 OS는 동적 메모리 할당을 지원함

### 동적 메모리 할당

* 운영체제는 메모리 위치를 가상화하여 프로그램의 메모리가 항상 주소 0에서 시작되도록 단순화함
* 실제 메모리의 위치는 운영체제에 의해 추상화되고 프로그램이 실행 될 때 요청 된 가상-실제 메모리를 OS가 자동으로 매핑하여 처리
* 이 덕분에 프로그램은 메모리 크기를 유연하게 관리 가능 + 비연속적인 메모리 위치가 연속적인 것처럼 보이게 함

## 1970-1980

컴퓨터의 성능이 향상 되면서 여러 사용자가 동시에 컴퓨팅 리소스를 공유 할 수 있게 됨

### 시간 공유

* 한 컴퓨터에 여러 개의 터미널을 연결하여 각 터미널마다 다른 사용자가 컴퓨터를 이용이 가능해짐
* 하지만 한 컴퓨터를 여러 사람이 동시에 사용하면서 한 사용자가 컴퓨터 자원을 다 먹어치우는 문제가 생겼고 이러한 문제를 방지하기 위하여 개별 사용자는 시간 공유를 통해 컴퓨터 프로세서, 메모리의 일부만 활용할 수 있도록 함

### 멀틱스(Multics)

* 시간 공유 기능을 최초로 도입한 운영체제
* 멀틱스는 상당히 복잡하고 OS 자체 메모리 사용량만으로도 상당히 커서 유닉스(Unix)의 등장 배경이 됨

### 유닉스(Unix)

* OS를 ```커널```과 ```프로그램/라이브러리``` 두 파트로 분리하였음
* 커널은 메모리 관리, 멀티 태스킹 등 I/O를 다루는데에 사용 -> OS 핵심기능
* 멀틱스는 에러 복구 코드가 프로그램의 상당 부분을 차지하는 반해 유닉스는 그러한 것들을 전부 빼버리고 단순화 하여 다양한 하드웨어에서 유닉스를 구동할 수 있게 됨

## 1980 ~

* MS-DOS, 윈도우를 포함한 다양한 운영체제들 등장

## 참고자료
* Operating Systems: Crash Course Computer Science #18
