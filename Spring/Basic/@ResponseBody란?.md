# @ResponseBody

* ```@ResponseBody```는 Spring 프레임워크에서 컨트롤러에서 리턴하는 데이터를 HTTP 응답 본문으로 바로 전송할 때 사용하는 어노테이션이다.
* 예를 들어, **JSON이나 XML 형태의 데이터를 응답으로 전송할 때** 사용한다. 
* 스프링은 컨트롤러에서 리턴하는 데이터를 자동으로 **직렬화**하여 HTTP 응답 본문으로 변환해준다.
* @GetMapping은 @ResponseBody를 포함하고 있으며, 지정된 메소드에서 객체를 반환하면 자동으로 객체를 직렬화하여 HTTP 응답 본문으로 전송한다.


## 직렬화

> 객체를 바이트 스트림으로 변환하는 과정

#### 🤔 그런데 왜 바이트 스트림으로 변환해야하지..?

자바 객체는 JVM 내 Heap 메모리 영역에 생성되며, 객체의 상태 정보를 네트워크를 통해 전송하기 위해서는 바이트 스트림으로 변환해야 한다.  
또한, 자바 객체는 메모리에 저장된 데이터가 메모리 주소를 참조하는데, 이 주소는 객체를 사용하는 동안 계속 변경될 수 있다.  
따라서, 객체를 전송할 때는 객체의 상태 정보를 바이트 스트림으로 변환하여 전송하는 것이 안전하고 바람직하다.  


#### 🤔 Serializable 인터페이스 ?

직렬화는 Java에서 제공하는 ```Serializable 인터페이스```를 구현함으로써 가능하다.

```java
public interface Serializable {
}
```

하지만 Serializable 인터페이스는 구현해야할 메소드가 없다. 그렇다면 왜 구현해야할까?
* Serializable 인터페이스는 자바 직렬화 메커니즘에서 객체를 직렬화하고 역직렬화하기 위한 마커 인터페이스이다.
* 마커 인터페이스란, 아무런 메서드나 필드를 갖지 않고 단지 클래스 혹은 인터페이스에 대한 부가적인 정보를 제공하는 인터페이스를 의미한다.
* 따라서 Serializable 인터페이스는 단순히 객체를 직렬화하고 역직렬화하기 위한 표시로 사용된다.
* 직렬화가 필요한 클래스에 Serializable 인터페이스를 구현하면, 해당 객체는 직렬화 가능한 객체로 인식되어서 직렬화할 수 있게 되며,
* 반면에 Serializable 인터페이스를 구현하지 않은 클래스는 직렬화가 불가능한 객체로 인식되어서 직렬화를 할 수 없다.

#### 🤔 그럼 어떻게 동작하는가?

직렬화를 위해서는 ```ObjectOutputStream```클래스의 writeObject() 메서드를 호출하면 된다.  
이 메서드는 인자로 전달된 객체를 바이트 스트림으로 변환하여 출력 스트림에 쓰게 된다.  
반대로, 역직렬화를 하기 위해서는 ```ObjectInputStream``` 클래스의 readObject() 메서드를 호출하면 된다.    
이 메서드는 입력 스트림에서 바이트 스트림을 읽어와 객체로 변환하며, 역직렬화된 객체는 다시 JVM의 Heap 메모리에 저장된다.

