# 내부 아키텍처 패턴

## 1. 레이어드 아키텍처

레이어드 아키텍처는 다음과 같이 구성된다.

- `프레젠테이션` → 화면 표현 및 전환 처리
- `비즈니스 로직` → 비즈니스 개념, 규칙, 흐름제어
- `데이터 액세스` → 데이터 처리


<img width="600" alt="스크린샷 2023-05-02 오후 5 35 14" src="https://user-images.githubusercontent.com/97823928/235618784-d62c5eec-8c46-43fe-946f-21e649ca710d.png">

레이어드 아키텍처는 레이어간 응집성을 높이고 의존도를 낮추기 위해 몇가지 규칙을 정의했다.

- 상위 계층이 하위 계층을 호출하는 **단 방향성**을 유지한다.
- 상위 계층은 하위의 여러 계층을 모두 알 필요 없이 **바로 밑의 근접 계층만 활용**한다.
- 상위 계층이 하위 계층에 영향을 받지 않게 구성해야 한다.
- 하위 계층은 자신을 사용하는 상위 계층을 알지 못하게 구성해야 한다.
- 계층 간의 호출은 **인터페이스를 통해 호출**하는 것이 바람직하다. (구현 클래스에 직접 의존하지 않음으로써 약한 결합을 유지해야 한다.)

<img width="608" alt="스크린샷 2023-05-02 오후 5 35 33" src="https://user-images.githubusercontent.com/97823928/235618836-433d6f60-b1a5-4e5e-8a60-0aaf4db44143.png">


이러한 구조는 DIP를 만족시키는 것처럼 보인다. 인터페이스를 통해서 소스코드가 추상에 의존하며, 구체에는 의존하지 않기 때문이다. 하지만 OCP에 위반하게 된다

→ 모든 계층이 각기 자신이 제공하는 기능에 대한 추상적인 인터페이스를 직접 정의하고 소유하는 구조이기 떄문이다. 이러한 구조에서는 제어흐름이 상위 계층에서 하위 계층으로 흐르게 되고, 소스코드의 의존성은 제어 흐름의 방향대로 따를 수 밖에 없다.

→ 상위 계층은 하위 계층의 구체 클래스가 아닌 추상 인터페이스에 의존하고, 인터페이스의 구현체를 달리하는 방법으로 의존성을 줄일 수 있고, 다형성은 유지되나, 인터페이스는 그 계층이 정의하는 추상 특성의 한계를 벗어날 수 없다

→ Layer B의 클래스 C에서 D로 교체된 경우 비즈니스 로직은 영향을 받지않지만, 인터페이스 B가 교체된 경우에는 비즈니스 계층의 클래스가 데이터 액세스 계층의 인터페이스에 의존하게 된다. → 문제는 **인터페이스의 위치**
<img width="703" alt="스크린샷 2023-05-02 오후 5 36 05" src="https://user-images.githubusercontent.com/97823928/235618933-a05480dd-883c-4ae0-a60b-d99424895fd9.png">


- 데이터 액세스 계층에서 정의한 인터페이스를 **비즈니스 로직 계층으로 옮기게 되면**,  데이터 액세스 계층의 구현체가 비즈니스 로직의 인터페이스를 바라볼 수 밖에 없다.
- 즉 고수준의 영역(= 비즈니스 로직 영역)을 보호할 수 있다.


## 2. 헥사고날 아키텍처

<img width="629" alt="스크린샷 2023-05-02 오후 5 36 13" src="https://user-images.githubusercontent.com/97823928/235618977-6c8e5e08-ed34-4311-a487-561b8ec3a3b9.png">

헥사고날 아키텍처는 다음과 같이 구성된다.

- `내부영역`
    - 고수준의 비즈니스 로직을 표현
    - 외부영역과 연계되는 **포트**를 가지고 있음
        - 인바운드 포트 : 내부 영역의 사용을 위해 표출된 API. 외부 영역의 인바운드 어댑터가 호출
        - 아웃바운드 포트 : 내부 영역이 외부영역을 호출하는 방법을 정의
- `외부영역`
    - 저수준의 영역, 인터페이스 처리를 담당
    - 인바운드 어댑터 : 외부에서 들어오는 요청을 처리
    - 아웃바운드 어댑터 : 비즈니스 로직에 의해 호출되어 외부와 연계
    

헥사고날 아키텍의 가장 큰 특징은 **고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않는다**는 것이다

→ 이는 내부 영역에 구성되는 **포트**로 인해 가능해진다.

## 3. 클린 아키텍처

클린 아키텍처는 엔티티, 유스케이스, 그 외 세부사항으로 구분한다.
<img width="485" alt="스크린샷 2023-05-02 오후 5 36 27" src="https://user-images.githubusercontent.com/97823928/235619017-024d8407-13df-495f-9326-377bd03b757d.png">



**엔티티**

- 도메인의 업무를 규정하는 핵심 업무 규칙들과 그 규칙들이 요구하는 데이터의 결합

**유스케이스**

- 자동화된 시스템을 사용하는 처리 절차를 기술한다.
- 유스케이스는 애플리케이션에 특화된 업무 규칙을 표현하며 엔티티 내부의 핵심 업무 규칙을 호출하며 시스템을 사용하는 흐름을 담는다.

**세부사항**

- 세부사항은 입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜이 될 수 있으며, 세부사항과 유스케이스 관계를 의존관계 역전의 법칙을 이용하여 플러그인처럼 유연하게 처리해야 한다. 이런 명확한 결합의 분리는 테스트 성 및 개발 독립성, 배포 독립성 강화할 수 있다.

## 4. 내부 아키텍처 정의

앞서 살펴본 3가지의 아키텍처가 지향하는 바를 모아 바람직한 마이크로서비스의 내부 구조를 정의해보자.

```dart
- 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.
- 업무 규칙을 정의하는 비지니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다.
- 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분된다.
- 고수준 영역은 저수준영역에 의존하지 않도록 해야하며 저수준영역이 고수준영역을 의존하게 해야 한다.
- 저수준 영역은 언제든지 교체, 확장 가능 하게 해야 하며, 이 변화가 고수준영역에 영향을 주면 안 된다.
- 자바 언어의 경우 저 수준 영역의 고수준 영역 의존을 위해 인터페이스를 통한 의존성 역전의 법칙을 활용한다.
- 인터페이스는 고수준의 안정된 영역 존재해야 하여 저 수준의 어댑터가 이를 구현한다.
```

<img width="709" alt="스크린샷 2023-05-02 오후 5 36 43" src="https://user-images.githubusercontent.com/97823928/235619070-ddf58283-dafb-4c6a-a6b7-54a14e172d85.png">

- 내부 영역
    - 맨 안쪽에 도메인이 존재하고, 도메인을 서비스가 감싼다.
    - 도메인에는 핵심비즈니스 개념과 규칙을 규현하고, 서비스는 도메인을 호출해서 처리한다.
    - 외부 영역과 연계하기 위해서 서비스 인터페이스를 보유한다.
    - 저장소 처리를 위해 리포지토리 인터페이스를 정의한다.
- 외부 영역
    - 저장소처리 어댑터, 인바운드 아웃바운드 어댑터, .. 등등 여러개의 어댑터가 위치한다.
    - 모든 아웃바운드 어댑터는 의존관계 역전을 적용해 외부 여역에서 내부 영역에 의존하도록 설계한다.
    

### 4-1. (내부영역) 트랜잭션 스크립트 패턴

<img width="362" alt="스크린샷 2023-05-02 오후 5 37 10" src="https://user-images.githubusercontent.com/97823928/235619177-7b7cf51e-520e-48c6-9909-b55ac3d47fa1.png">

- 도메인 객체가 비지니스 개념을 정의하되 **행위를 가지고 있지는 않다**.
    - → 모든 비지니스 행위, 즉 책임은 서비스에 존재
- 서비스가 비지니스 절차에 따라 절차적으로 도메인 객체를 이용하여 모든 처리를 수행한다.
- 비즈니스가 복잡해질 경우, 서비스 코드 양이 증가하고, 데이터베이스 중심 아키텍처의 문제점이 발생할 수 O

### 4-2. 도메인 모델 패턴

- 도메인 객체가 데이터 뿐만 아니라 비지니스 행위를 가지고 있으며 도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉된다
- 도메인 객체는 각각의 비지니스 개념 및 행위에 대한 책임을 수행하고, 서비스의 행위들은 대부분의 비지니스 처리를 도메인 객체에게 위임한다.

### 4-3. 에그리거트 패턴

<img width="472" alt="스크린샷 2023-05-02 오후 5 37 20" src="https://user-images.githubusercontent.com/97823928/235619209-f7f18178-f967-48f5-8061-c879fdbec200.png">

- **도메인 주도 설계(Domain Driven Design : DDD)**에 등장하는 패턴으로 점점 복잡해 질 수 있는 객체 모델링 단점을 보완한 패턴
- 도메인 모델링을 하다 보면 객체간의 관계를 참조로 정의한다. 참조로 정의하면 일 대 다의 관계의 객체를 쉽게 사용할 수 있는 장점이 있으나 업무가 복잡해지면 참조로 인해 계층구조가 여러 단계를 가지게 되고 점점 참조 관계가 복잡해지고 무거워질 수 있다.
- 복잡한 모델을 세 덩어리의 개념으로 분리할 수 있다. 1개 이상의 엔티티와 Value Object 로 구성된다. 제일 상위에 있는 루트 엔티티를 `에그리게잇`이라 한다.
- 규칙
    - 애그리게잇 루트만 참조한다. 애그리게잇 내 상세클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다. 수정도 마찬가지이다.
    - 애그리게잇간 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다. 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 애그리게잇을 함께 수정하는 실수를 방지한다.
    - 하나의 트랜잭션으로 하나의 애그리게잇만 생성,수정한다.

### 4-4. (외부영역) **API퍼블리싱 어댑터**

- REST API를 발행하는 인 바운드 어댑터
- 내부 영역의 서비스 인터페이스를 호출하여 REST 형식의 API로 제공
- 엔티티를 직접 제공하지 않고 API 필요해 맞는DTO(Data Transfer Object)를 생성, 엔티티를 이용 매핑하여 전달하는 것이 바람직

### 4-5. **API 프록시 어댑터**

- 다른 서비스의 API를 호출하는 아웃바운드 어댑터
- 내부 영역의 정의된 추상화된 프록시 인터페이스를 구체화 한다.

### 4-6. **저장소 처리 어댑터**

저장소 처리 어댑터 구현 시 **OR 매핑 방식과 SQL 매핑 방식 중 하나를 선택할 수 있다.**

- 내부영역에서 어떤 구조를 선택하였던지 둘 다 사용할 수 있으나, 일반적으로 트랜잭션 스크립트 패턴을 사용했을 경우 SQL매핑 방식을 사용하고, 도메인 모델 패턴을 사용했을 경우 OR매핑 방식을 많이 선택한다.
- SQL 매핑 방식의 프레임웍으로는 MyBatis가 가장 많이 사용되고 OR 매핑 방식으로 JPA나 Spring.Data가 많이 사용된다. SQL 매핑 방식은 SQL 질의문을 수동으로 작성해야 하므로 세밀한 SQL 컨트롤이 필요한 경우 유용하다. OR매핑 방식은 OR 매퍼가 저장소에 따라 런타임 시 자동으로 질의문을 생성한다. 따라서 SQL 작성에 대한 워크로드를 줄일 수 있다.

### 4-7. **도메인 이벤트 발행 어댑터**

도메인 이벤트는 어떤 사건에 따른 상태의 변경 사항을 말하여 ‘ 주문됨, 주문 취소됨 등’의 명칭를 갖는 클래스로 정의되며 컨슈머에게 전달되기 위해 도메인 이벤트 발행 어댑터를 통해 발행된다. 애그리게잇 패턴을 적용했을 경우, 이런 도메인 이벤트는 애그리게잇에서 발생한 사건이 된다.실제로 도메인 이벤트가 생성되는 위치는 내부 영역이며 도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스를 구현하여 아웃바운드로 특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행한다.

### 4-8. **도메인 이벤트 핸들러**

도메인 이벤트 발행 어댑터가 있다면 당연히 인 바운드 어댑터도 필요하다. 도메인 이벤트 핸들러는 외부에서 발행된 도메인 이벤트를 구독하여 내부영역으로 전달하는 일을 수행한다. 이벤트 상태에 따라 적절한 서비스 인터페이스를 호출한다.
