## Index

> 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

## Index 개요
책에서 원하는 내용을 찾기 위해서 책의 모든 페이지를 찾는 것은 오랜 시간이 걸린다.   
그래서 책의 저자들은 ```색인```을 추가하는데, 이 색인이 데이터베이스의 인덱스와 같은 역할을 한다.

인덱스는 ```key-value```의 쌍 형태로 이루어져 있는데,
* 데이터는 책의 내용이고, 데이터가 저장된 레코드의 주소는 페이지 번호가 될 것이다.
* DBMS는 데이터베이스 테이블의 모든 데이터를 검색하여 원하는 결과를 조회하기 위해서는 오랜 시간이 걸리므로, 
* **컬럼의 값**과 **해당 레코드가 저장된 주소**를 키와 값의 쌍 형태로 인덱스를 만들어둔다.

## 💡 Index 성능과 고려 사항

DBMS의 인덱스는 **항상 정렬된 상태를 유지**하기 때문에 ```원하는 값을 빠르게 탐색```할 수 있다. 
하지만 **INSERT, UPDATE, DELETE의 경우 추가적인 연산이 수행**되므로 그에따른 오버헤드가 발생한다.
* ```INSERT``` : 인덱스에 대한 데이터도 추가해야하므로 성능 손실 발생
* ```DELETE``` : 인덱스에 존재하는 값은 삭제하지 않고 사용 안한다는 표시만 남게 됨 -> row의 수는 그대로
* ```UPDATE``` : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

> 인덱스는 데이터의 저장 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다.

* 하지만 삽입, 수정, 삭제 연산이 빈번하게 발생하는 경우, 실제 데이터는 1만건인데 추가적인 연산으로 10만건이 되는 결과를 낳을 수 있다. 
* == 인덱스의 크기가 비대해져 성능이 오히려 저하될 수 있다.

#### 인덱스를 사용하면 좋은 경우
* 규모가 작지 않은 테이블
* 삽입, 삭제, 수정이 빈번하지 않는 컬럼
* 데이터의 중복이 낮은 컬럼
* JOIN, WHERE, ORDER BY에 자주 사용되는 컬림
* 값의 range가 큰 경우 (성별같은 경우 인덱스를 읽고 다시 디스크 I/O가 발생하므로 비효율적)

## 출처
* https://k39335.tistory.com/26
* https://mangkyu.tistory.com/96
