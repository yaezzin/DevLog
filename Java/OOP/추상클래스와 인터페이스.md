## 추상클래스 

```java
public abstract class 클래스이름 {
    public abstract void 메서드이름();
}
```

#### 미완성 설계도
* 새로운 클래스를 작성하는데 있어서 바탕이되는 조상클래스로서 중요한 의미를 가진다.
* 공통부분만을 그린 미완성 설계도를 만들어 놓고, 이 미완성 설계도를 이용하여 각각의 설계도를 완성하는 것이다.
* 추상클래스로는 인스턴스를 생성할 수 없으며, 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.

#### 추상화

* 상속이 자손 클래스를 만들기 위해 조상 클래스를 사용하는 것이라면, 이와 반대로 ```추상화```는 ```기존의 클래스의 공통부분만을 뽑아내서 조상 클래스를 만드는 것```이라 할 수 있다.

### 차이점
#### 1. 빈 몸통만 만들어 놓기

```java
class Player {
    ...
    void play(int pos) { }
    void stop() { }
}
```

#### 2. 추상 클래스 및 메서드로 선언하기
```java
abstract class Player {
    abstract void play(int pos);
    abstract void stop();
}
```

Q. 어차피 자손 클래스에서 오버라이딩하여 자신의 클래스에 맞게 구현할테니 추상메서드로 선언하는 것과 내용없는 빈몸통만 만들어 놓는 것은 별차이가 없어보인다. 그런데 왜 굳이 ```abstract```를 붙여 추상메서드로 선언하는 것일까?
* 이는 자손클래스에서 추상메서드를 반드시 구현하도록 **강요**하기 위해서 이다.
* 빈 몸통만 가지도록 정의되어있다면 상속받는 자손 클래스에서는 이 메서드들이 온전히 구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하지 않을 수도 있기 때문이다.

## 인터페이스

```java
interface 인터페이스이름 {
    public abstract void 메서드이름();
    public default void 메서드이름() {};
}
```

인터페이스도 일종의 추상클래스이다.
* 추상클래스는 구현부가 있는 메서드와 멤버변수를 구성원으로 가질 수 있는 반면, 인터페이스는 ```상수```와 ```추상메서드```만을 멤버로 가질 수 있다.
* 제약조건
  * 인터페이스는 모든 멤버변수가 ```public static final```이어야 하며, 이를 생략할 수 있다.
  * 모든 메서드는 ```public abstract```이어야하며, 이를 생략할 수 있다. 
    * (static메서드와 디폴트 메서드는 예외 JDK 1.8부터)

## 추상클래스와 인터페이스의 공통점

* 선언만 있고, 구현 내용이 없다 (추상메서드는 구현 내용이 있을 수도 있다.)
* 자기 자신이 new를 통해 객체를 생성할 수 없으며, 상속받은 자식만이 객체 생성이 가능하다
* 상속받은 자식은 내부 구현을 반드시 해야한다.

## 차이점 ?

|추상 클래스 | 인터페이스|
|-----------|----------|
|```abstract```를 붙여서 표현| ```interface```를 붙여 표현|
|```extends```를 사용| ```implements```를 사용|
|메서드의 부분적인 구현이 가능 </br>(선언부만 있을 수도, 구현부까지 있을 수도 있음)| 메서드의 선언만 가능|
|일반 변수 + 일반메서드 + 추상메서드|상수 + 추상메서드|
|다중 상속 불가| 다중 상속 가능|
|추상클래스를 상속받아 기능을 이용하고, 확장시키기 위해 사용| 구현 객체의 같은 동작을 보장하기 위해 사용|


## 사용케이스

### 추상클래스
추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것
* 상속 관계를 타고 올라갔을 때 같은 부모 클래스를 상속하며 부모 클래스가 가진 기능들을 구현해야할 경우 사용하자
* 관련성이 높은 클래스 간 코드를 공유하고 싶은 경우 추상 클래스를 상속 받을 클래스들이 공통으로 가지는 메소드와 필드가 많거나, public이외의 접근자(protected, private) 선언이 필요한 경우
* non-static, non-final 필드 선언이 필요한 경우 (각 인스턴스에서 상태 변경을 위한 메소드가 필요한 경우)
* 즉 ```bottom up →  필요기능 모아서 (집중)```

### 인터페이스
* 인터페이스는 상속 관계를 타고 올라갔을 때 ```다른 조상 클래스를 상속```하더라도, ```같은 기능이 필요```할 경우 사용한다. 
* 클래스와 별도로 구현 객체가 ```같은 동작```을 한다는 것을 보장하기 위해 사용한다
* 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우
* ```다중상속```을 허용하고 싶은 경우
* ```top dowon →  필요기능 구현해 (분산)```

## 참고자료
[(1) 이동](https://haenny.tistory.com/162)
[(2) 이동](https://velog.io/@new_wisdom/Java-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4)
