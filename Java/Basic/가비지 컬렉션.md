# 가비지 컬렉션

## 1. 객체의 소멸

객체 소멸이란 new에 의해서 생성된 객체 공간을 JVM(Java Virtual Machine)에 돌려주어 가용 메모리에 포함시키는 것이다.
* C++의 경우 객체가 소멸될 때 소멸자 함수가 호출되어 필요한 마무리 작업을 수행하도록 한다.
* 하지만 자바는 delete연산자도 소멸자도 없으므로 할당받은 메모리를 반환해야하는 부담이 없다.
* 자바의 경우 가비지 컬렉터가 적절한 시점에 자동으로 수집하여 가용 메모리에 반환시킨다.

## 2. 가비지 (Garbage)

가비지란 자바 프로그램에서 더 이상 사용되지 않게 된 객체나 배열 메모리이다. 
* 자바 플랫폼은 **참조하는 레퍼런스가 하나도 없는** 객체나 배열을 가비지로 판단

```java
a = new Person("부승관");
b = new Person("차은우")
b = a; // b가 가리키던 처음 객체인 차은우는 아무도 참조하지 않게 되어 더이상 접근 불가
```

## 3. 가비지 컬렉션 (Garbage collection)

가비지는 더이상 참조되지 않으므로 가비지가 차지하고 있는 메모리 공간을 회수하여 가용 메모리를 늘려야 한다.
* 가비지 컬렉션은 가용 메모리가 일정 크기 이하로 줄어들면 자동으로 가비지를 회수한다.

#### 가비지 컬렉션 강제 요청

```java
System.gc();
```
응용프로그램에서 System 또는 Runtime 객체의 gc() 메소드를 호출하면 가비지 컬렉션을 노출할 수 있다.
* 하지만 이 문장은 가비지 컬렉션이 필요하다는 요청에 불과하므로 문장 호출 즉시 가비지 컬렉터가 작동하는 것은 아니다.
* 가비지 컬렉션은 자바 플랫폼이 전적으로 판단하여 적절한 시점에 작동시킨다.
* (해당 메소드를 호출하는 것은 시스템의 성능에 매우 큰 영향을 미치므로 호출하는 것을 지양하라.)

# 가비지 컬렉션의 작동원리 

## Minor GC와 Major GC

JVM의 Heap 영역은 2가지의 전제를 기반으로 설계되었다.
* 객체는 금방 접근 불가능한(Unreachable) 상태가 된다.
* 오래된 객체에서 새로운 객체로의 참조는 거의 존재하지 않는다. 

> 즉, 객체는 대부분 일회성이며 메모리에 오래 머무르는 경우는 드물다는 것이다.  

이러한 객체의 생존기간에 따라 힙영역을 Young, Old로 구분하여 설계하였다.   
(초기에는 Perm  영역도 존재하였지만 Java8부터 삭제되었다.)

```Young Generation```
* 새롭게 생성된 객체가 할당되는 영역
* 대부분의 객체가 금방 접근 불가능한 상태가 되므로 대부분의 객체가 이 영역에 생성되었다가 사라지게 된다.
* Young 영역에 대한 가비지 컬렉션을 ```Minor GC```라고 한다.

```Old Generation```
* Young 영역에서 살아남아 객체가 복사되는 영역
* Young 영역보다 크게 할당된다. (Young영역의 생존기간이 짧은 객체는 큰 공간이 필요 없으며 큰 객체가 Old 영역에 할당되므로!) 
* Old 영역에 대한 가비지 컬렉션을 ```Magor GC```  또는 ```Full GC```라고 한다.


## 동작 방식 (공통)

Young영역과 Old영역은 서로 다른 메모리 구조를 가져 세부적인 동작방식은 다르나 다음의 2가지 공통적인 단계를 따른다.

### 1. Stop The World

> 가비지 컬렉션을 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업
* GC가 실행되면 GC를 실행하는 쓰레드를 제외한 모든 쓰레드의 작업이 중단된다.
* 모든 쓰레드의 작업을 중단시키는 것은 애플리케이션이 멈춘다는 것이므로 GC 성능 개선을 위해서는 Stop The World의 시간을 줄여야 한다.

### 2. Mark and Sweep

> Mark : 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
* stop-the-world를 통해 모든 작업을 중단시키면 GC는 스택의 모든 변수 및 접근불가능객체를 스캔하여 어떠한 객체를 참조하는지 탐색한다
* 이때 사용되고 있는 메모리를 식별하는 작업을 Mark라고 한다.
> Sweep : Mark 작업에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

## Minor GC의 동작 방식

1. 새로 생성된 객체가 ```Eden 영역```에 할당된다.
2. 객체가 계속 생성되어 **Eden 영역이 꽉차게 되면**  ```Minor GC```가 실행된다.
* Eden 영역에서 사용되지 않는 객체의 메모리가 해제된다.
* Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동된다.
3. 1~2번의 과정이 반복되다가 Survivor 영역이 가득 차게 되면 Survivor 영역의 살아남은 객체를 ```다른 Survivor``` 영역으로 이동시킨다.
* (1개의 Survivor 영역은 반드시 빈 상태가 된다.)
4. 이러한 과정을 반복하여 계속해서 살아남은 객체는 ```Old 영역```으로 이동(Promotion)된다.

```text
# Young 영역은 1개의 Eden영역과 2개의 Survivor영역으로 구성되어있다.
- Eden 영역 : 새로 생성된 객체가 할당되는 영역
- Survivor 영역 : 최소 1번 이상의 GC에서 살아남은 객체가 존재하는 영역
- 객체의 생존 횟수를 카운트 하기 위해 Minor GC에서 객체가 살아남은 횟수인 age를 Object Header에 기록한다.
- 그리고 Minor GC 때 Object Header에 기록된 age를 보고 Promotion 여부를 결정한다.
```

## Major GC 동작방식

Young 영역에서 오랫동안 살아남은 객체는 Old 영역으로 Promotion되는데, Major GC는 객체들이 계속 Promotion되어 **Old 영역의 메모리가 부족해지면** 발생된다.
* Old 영역은 크기가 크고 Young 영역을 참조할 가능성이 있으므로 Major GC는 일반적으로 Minor GC보다 오래걸린다.
