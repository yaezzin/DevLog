# JVM의 동작원리

1. 작성한 자바 소스(.java)를 자바 컴파일러를 통해 자바 바이트 코드(.class)로 컴파일한다.
2. 컴파일된 바이트코드를 JVM의 클래스 로더에게 전달합니다.
3. JVM의 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, 즉 JVM의 메모리에 올린다.
4. 메모리에 올라온 바이트 코드들을 실행엔진이 명령어 단위로 하나씩 가져와서 실행한다. (이때 JVM이 컴퓨터가 실행할 수 있는 형태로 변경)

## 인터프리터 & JIT 컴파일러

클래스 로더가 런타임 데이터 영역으로 클래스를 올리면 실행엔진이 자바 바이트 코드를 JVM이 컴퓨터가 실행할 수 있는 형태로 변경한다.  
이를 컴퓨터에서 실행시키기 위해서는 Native code로 변환해야한다.

#### 💡 인터프리터

인터프리터는 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 한줄 한줄 해석하기 때문에 속도가 느리다.

#### 💡 JIT 컴파일러

반면 JIT 컴파일러는 자주 반복되는 코드를 기계어로 변환해서 ```캐싱```을 해놓고 이를 꺼내어 바로 실행하기 때문에 상대적으로 빠르다.  

* JIT 컴파일러와 인터프리터는 동시에 런타임 영역에서 다른스레드에서 실행된다.
* JIT 컴파일러는 바이트코드를 nativecode로 바꾸기 때문에 실행이 빠르지만 변환하는데 비용이 발생한다.
* 이러한 변환 비용 때문에 JVM은 인터프리터 방식을 사용하다 자주 사용되는 코드만 캐싱한다.
* JVM은 내부적으로 어떤 메서드가 얼마나 자주 수행되는지를 확인하고 HotSpot이라고 판단하면 컴파일을 수행해놓습니다.

이러한 과정을 통해 바이트코드는 JVM 내부에서 컴퓨터가 실행할 수 있는 형태로 변경되어 실행된다.

## 참고자료
* https://tjdrnr05571.tistory.com/19
