# 자바 가상 머신 JVM 

## JVM의 동작방식

1 ) 자바 소스코드를 (.java)을 javac 컴파일러에 의해 바이트코드(.class)로 컴파일한다.

2 ) Class Looader는 .class 파일을 로드하여 JVM 내 메모리(Runtime Data Area)에 할당한다

* 어떤 메소드가 호출되려면 메소드를 갖고 있는 클래스 파일이 메모리에 할당되어야 하므로,,
* 이때 클래스의 구조와 메타데이터가 메서드 영역에 기록된다.

3 ) Execution Engine은 JVM 메모리에 올라온 바이트 코드들을 JVM내부에서 실행할 수 있도록 해석한다.
* 이 때 Java 인터프리터와 JIT(Just-In-Time) 컴파일러를 사용한다.

4 ) Execution Egine에 의해 Garbage Collector가 작동하고 스레드 동기화가 이루어진다.


# JVM의 구조 

## 1. 클래스 로더 Class Loader


JVM에서 클래스를 로딩하는 단계는 크게 ```로딩(Loading)```, ```링크(Linking)```, ```초기화(Initialization)``` 단계로 나누어진다.

#### 1 ) Loading 로딩

Class Loader는 자바 클래스파일(*.class)을 찾아서 JVM의 메모리 영역인 Runtime Data Area에 로드한다.

#### 2 ) Linking 링크

링크 과정에서는 클래스의 실제 사용을 위해 검증, 준비, 해결의 3단계로 나뉘어진다.
* 검증(Verification): 클래스 파일이 JVM의 규칙과 바이트코드 규칙에 맞는지 검사한다.
* 준비(Preparation): 클래스의 정적 변수(static)에 디폴트 값을 할당한다. (ex. 정적 int 변수는 0으로 초기화)
* 해결(Resolution): 심볼릭 참조(클래스, 메소드, 필드 등)가 메모리 주소의 직접 참조로 변경된다.

#### 3 ) Initialization 초기화

모든 클래스의 정적 변수가 실제 값으로 설정되고 초기화가 완료된다. (ex. static int num = 10;)


## 2. 실행엔진 Execution Engine

실행엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트코드를 기계어로 변환하여 실행하는 부분이다. 이 과정에서 실행엔진은 인터프리터와 JIT 컴파일러를 사용하여 바이트 코드를 변환한다.

```
바이트코드 : Java, Python 등으로 작성된 프로그램을 컴파일한 결과 (.class) -> JVM에 의해 실행됨
기계어 : CPU가 이해하고 실행할 수 있는 이진코드  
```

#### 인터프리터
* 바이트 코드를 한 줄 씩 해석하고 실행하지만 속도가 느리다는 단점을 가진다.

#### JIT 컴파일러

* 바이트 코드 전체를 컴파일해서 미리 기계어로 변환하여 캐시해두고, 기계어로 직접 실행하는 방식이다. 하나씩 해석 하는 것이 아니라 컴파일된 기계어를 실행하는 것이기 때문에 인터프리터 방식보다 빠르다. 하지만 바이트코드를 기계어로 변환하는 비용이 존재하기 떄문에, 인터프리터 방식을 사용하다 일정 기준이 넘어가면 JIT컴파일러 방식을 사용한다.


## 3. Runtime Data Area 런타임 데이터 영역

런타임 데이터 영역은 JVM이 프로그램을 수행하기 위해 운영체제로부터 할당받는 메모리 영역이다. 좌측 3개의 영역은 스레드 별로 생성되며, 우측 2개의 영역은 모든 스레드가 공유한다.


### 📌 Method Area  메서드 영역


메서드 영역은 클래스 파일을 메모리에 로드할 때 클래스에 대한 구조와 메타데이터가 저장되는 메모리 공간이다. JVM이 무언가를 실행하기 위해서는 먼저 그 바이트 코드들이 메모리에 로드되어야 하며, 이때 메서드, 필드, 인터페이스 정보, 메서드의 바이트코드, 상수 풀, 그리고 정적(static) 변수 정보가 메서드 영역


### 📌 Heap 힙 영역


JVM의 힙 영역은 new 키워드로 생성된 객체들이 실제로 할당되고, GC를 통해 관리되는 메모리 영역이다. 힙영역은 모든 스레드가 공유하며, 프로그램 실행 중 동적으로 생성되는 객체들이 저장된다. 즉, new를 통해 객체를 생성할때 객체와 관련된 인스턴스 변수(멤버 변수)가 힙에 저장된다.


#### 원시형 변수 

원시형 변수(ex. int, boolean 등)는 힙영역이 아닌 스택에 변수와 내용을 모두 저장한다.

#### 참조형 변수 

반면 참조형 변수(ex. String, Object)는 스택에 저장된 객체의 메모리 주소(즉 참조값)을 저장하고, 실제 내용은 힙 영역에 저장한다. 즉 JVM의 스택에 저장된 참조 주소를 통해 힙 영역에 있는 객체로 접근하게 되는 것이다.

#### Heap과 Garbage Collection

이 때 JVM은 참조가 끊어진 객체를 찾아서 가비지 컬렉션을 통해 메모리에서 삭제한다. 이로써 메모리 누수를 방지하고 효율적인 메모리 관리를 돕는다. JVM은 효율적인 GC를 수행하기 위해 힙 영역을 다음과 같이 구분한다. 

#### Young Generation

Eden : 새로 생성된 객체가 위치하는 곳
Survivor 0, Survivor 1 : 살아남은 객체가 순차적으로 이동하는 공간


#### Old Generation

생명주기가 긴 객체가 이동하는 공간


#### Permanent Generation 또는 MetaSpace(JVM 8~)

클래스의 메타데이터와 관련된 정보들이 저장되는 영역


### 📌 Stack 스택

스택은 기본 자료형, 지역변수, 매개변수 등 임시로 사용되는 정보들이 저장되며, 객체의 참조값도 저장된다.
스택은 LIFO(Last In First Out) 구조를 가져 나중에 들어간 데이터가 먼저 나오게 된다. 스택은 메서드가 호출되면, 해당 메서드의 새로운 스택 프레임(메서드만의 공간)이 추가(push)되고, 해당 메서드에 필요한 매개 변수와 지역변수가 저장된다. 메서드가 실행되면 필요한 작업이 수행되고, 그 작업이 끝나면 스택 프레임이 스택에서 제거(pop) 된다.

### 📌 PC Regiser 

PC 레지스터는 스레드마다 독립적으로 존재하며, 각 스레드가 현재 실행해야 하는 JVM 명령어의 주소를 보유하는 레지스터이다. 스레드가 어떤 부분을 어떤 명령으로 실행해야할지 추적하는 장치로, 현재 수행중인 JVM 명령의 위치를 나타낸다. PC 레지스터는 JVM 내부에서만 존재하며 실제 컴퓨터의 물리적 하드웨어와는 직접 연결되는 것은 아니다.

Java의 PC 레지스터와 달리 CPU의 레지스터는 하드웨어 레벨에서 CPU에 실제로 존재하는 물리적인 기억장치이다. 컴퓨터가 프로그램을 실행하려면 그 프로그램이 저장된 곳에서 한줄씩 명령어를 가져와서 CPU가 직접 실행하는데, 이때 CPU는 현재 어디까지 실행했는지 기억해야하는데 이를 PC 레지스터에 메모리 주소를 기록한다.


### 📌 Native Method Stack 

네이티브 메서드 스택은 기계어로 작성된 프로그램을 실행시키는 영역이다. 앞서 말한 JIT 컴파일러에 의해 변환된 원시 코드도 이 곳에서 실행된다.



## 참고자료

* https://medium.com/@fullstacktips/java-memory-management-understanding-the-jvm-heap-method-area-stack-27c895fcce44
* https://velog.io/@sunggil-5125/JVM-%EC%9D%B4%EB%9E%80
