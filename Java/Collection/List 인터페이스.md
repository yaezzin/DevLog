# List 인터페이스 
List 인터페이스는 중복을 허용하면서, 저장순서가 유지되는 컬렉션을 구현하기 위해 사용된다

## 1. ArrayList

* ArrayList는 List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고, 중복을 허용한다.
* Object 배열을 이용하므로 인덱스를 통해 요소 접근(조회)에 있어 성능이 좋다.
* 삽입, 삭제의 경우에는 복잡한 과정을 거쳐 배열의 크기를 동적으로 이용하기에 성능이 나쁨
* 삽입, 삭제의 경우 데이터를 한칸씩 옮겨서 작업하는데, 마지막 요소를 작업한다면 자리이동에 대한 영향이 감소한다.

  ```java
    /* 예시 */
    for (int i = list2.size() - 1; i >= 0; i--) { // 마지막 요소부터 접근
        if (list1.contains(list2.get(i))) {
            list2.remove(i);
        }
    }
    ```

## 2. LinkedList

LinkedList는 ArrayList가 내부적으로 **배열을 이용함에 따라 발생하는 단점**을 개선하기 위해서 만들어졌다.

```
# 배열의 단점
1. 크기를 변경할 수 없다.
- 크기 변경이 불가능하므로 새로운 배열을 생성해서 데이터를 복사해야한다.
- 실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리 낭비가 발생한다.

2. 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
- 차례대로 데이터를 추가하고 마지막부터 데이터를 삭제하는 것은 빠르나,
- 배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.
``` 

LinkedList는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.
* 링크드 리스트의 각 요소들은 자신과 연결된 다음 요소에 대한 주소값과 데이터로 구성되어있다.

```java
class Node {
    Node next;  // 다음 요소의 주소를 저장
    Object obj;  // 데이터를 저장
}
```

### 삭제

<img width="459" alt="스크린샷 2023-01-17 오후 6 44 24" src="https://user-images.githubusercontent.com/97823928/212864349-9ff8eb53-3645-48d6-9bd3-994495a05380.png">

* 삭제하고자 하는 요소의 이전요소가 // 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경하면 된다.
* 단 한번의 참조 변경으로 삭제가 이루어 진다.

### 삽입

<img width="463" alt="스크린샷 2023-01-17 오후 6 45 36" src="https://user-images.githubusercontent.com/97823928/212864742-c1beb98b-8f82-40ed-88a3-bdccbf22a203.png">

* 새로운 요소를 생성한 다음 // 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경한 후,
* 새로운 요소가 그 다음 요소를 참조하도록 변경하면 된다.

## 3. ArrayList vs LinkedList 성능차이

### 1. 조회

* ArrayList는 ```인덱스```를 통해 각 요소를 조회하기 때문에 ```O(1)``` 의 시간 복잡도를 가진다. 
* 반면 LinkedList는 검색 시 불연속적으로 위치한 각 요소를 탐색해야 하기 때문에 ```O(N)```의 시간 복잡도를 가진다.
  * LinkedList는 저장해야하는 데이터의 개수가 많아질수록 접근시간이 길어진다.

### 2. 저장, 삭제

```순차적```으로 추가/삭제 하는 경우에는 ```ArrayList```가 더 빠르다.
* 순차적으로 삭제하는 것은 마지막 데이터부터 역순으로 삭제해나가는 것을 의미한다.
* 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 빠르다. (단순히 마지막 요소의 값을 null로만 바꾸면 되므로!)

```중간 데이터```를 추가/삭제하는 경우에는 ```LinkedList```가 더 빠르다.
* LinkedList는 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문이다. ```O(1)```
* 반면 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈공간을 채워야 하므로 처리속도가 늦다. ```O(N)```

