## 프록시와 지연로딩

엔티티를 조회할 때 항상 연관된 엔티티가 같이 사용되는 것은 아니다. 
회원을 조회할 때 연관된 팀 엔티티는 비즈니스 로직에 따라 사용될 수도 아닐 수도 있다. 

그러므로 JPA는 **엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연**하는 방법을 제공한다. → ```지연로딩```

## 1. 프록시 기초

```em.find()```
* JPA에서 식별자로 엔티티 1개를 조회할 때는 em.find()를 사용하면 된다
* 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회함 (1차 캐시 → DB)
* 엔티티를 직접 조회하는 방법은 조회한 엔티티의 사용여부에 상관없이 DB를 조회하게 됨

```em.getReference()```
* 엔티티를 실제 사용하는 시점까지 DB 조회를 미루고 싶으면 em.getReference()를 사용하면 된다
* 이 메소드를 호출하면 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다
* 대신 **데이터베이스 접근을 위임한 프록시 객체를 반환**
* 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요 없으므로 이 메소드를 호출하여도 프록시가 아닌 실제 엔티티를 반환함

## 2. 프록시 특징

* 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 모양이 같다.
* 프록시 객체는 member.getName()처럼 **실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성**한다 → ```프록시 객체의 초기화```

## 3. 프록시 초기화

만약 member.getName()처럼 실제 사용이 된다면 ...
1. 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회
2. 실제 엔티티가 생성 되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청함 (초기화)
3. 영속성 컨텍스트는 DB를 조회해서 실제 엔티티 객체를 생성
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 보관
5. 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환

```초기화 내용 추가```
* 프록시 객체는 처음 사용할 때 1번만 초기화됨
* 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티가 되는 것은 아님 (→ 프록시 객체를 통해 실제 엔티티에 **접근**하는 것!)
* 초기화는 영속성 컨텍스트의 도움을 받아야 가능하므로 준영속 상태의 프록시를 초기화하면 예외가 발생함

## 참고
* 김영한 [자바 ORM 표준 JPA 프로그래밍](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788960777330)
