## 영속성 컨텍스트의 이점


### 1. 1차 캐시

* **em.find()** 호출 시 먼저 1차 캐시에서 엔티티를 찾고, 찾는 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회한다.
* ```1차 캐시 조회``` → ```1차 캐시에 없으면 데이터베이스 조회``` → ```데이터 베이스에 찾고자하는 엔티티가 있으면 1차 캐시에 올림``` → ```반환``` 의 과정을 거친다.

### 2. 동일성 보장

* em.find(Member.class, "member1")을 반복해서 호출해도 영속성 컨텍스트는 **1차 캐시에 있는 같은 엔티티 인스턴스를 반환**한다.
* 그러므로 동일성 비교 (==)가 가능해진다.

``` 
- 동일성 : 실제 인스턴스가 같음. 그래서 참조 값을 비교하는 == 비교 값이 같음
- 동등성 : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같음 
```
### 3. 쓰기 지연

* 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 SQL을 모아둔다.
* 트랜잭션을 커밋해야만 모아둔 쿼리를 데이터베이스에 보낼 수 있는데 이를 쓰기 지연이라 함
* 모아둔 쿼리를 데이터베이스에 한 번에 전달해서 성능 최적화가 가능해진다.

### 4. 변경 감지 

* JPA로 엔티티를 수정할 떄는 단순히 엔티티를 조회해서 데이터만 변경하면 된다 (em.update()같은 메소가 필요 없다!)
* 1차 캐시에 들어온 데이터에 스냅샷을 찍고, 커밋 시점에 엔티티와 스냅샷을 비교한 후 update SQL을 생성한다.
* 즉, 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 ```변경감지```라고 한다.
* 변경감지는 영속성 컨텍스트가 관리하는 **영속 상태**의 엔티티에만 적용된다.
* ```commit()을 호출``` → 엔티티 매니저 내부에서 ```flush() 호출``` → ```엔티티와 스냅샷을 비교```해서 변경된 엔티티 찾음 
* → 변경된 엔티티에 대한 쿼리를 생성하여 ```쓰기 지연  SQL 저장소```에 보냄 → ```트랜잭션 커밋```

```
- 플러시 : 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업
- 스냅샷 : 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해둔 것
```
