# 플러시 flush

> 영속성 컨텍스트에 저장된 변경 내용을 데이터베이스에 반영하는 작업

* ```FlushModeType.AUTO``` : 커밋이나 쿼리를 실행할 때 플러시 (기본값)
* ```FlushModeType.COMMIT``` : 커밋할 때만 플러시

#### 커밋과 플러시의 차이?

* 커밋이 일어나기 직전에 flush가 동작하게 되는데, 이때 쓰기 지연 저장소에 있던 쿼리들이 DB로 전달됨
* 이때 플러시와 커밋 둘 모두 DB에 동기화하는 작업이나, 플러시는 커밋이 되지 않아 에러가 발생하면 롤백할 수 있는 상태이고, 커밋은 커밋이 일어나게 되면 DB에 영구히 반영이 되어서 롤백할 수 없음!

## 영속성 컨텍스트를 플러시하는 방법

### 1. em.flush() 직접 호출

개발자가 직접 flush를 호출하여 데이터베이스에 변경 내용을 적용할 수 있음

### 2. 트랜잭션 커밋 시 flush() 자동 호출

트랜잭션을 커밋하기 전에 플러시를 호출해서 **영속성 컨텍스트의 변경 내용을 데이터베이스에 반영**해야 함  
JPA는 이런 문제를 예방하기 위해 트랜잭션을 커밋할 때 플러시를 자동으로 호출함

```변경 감지``` 
1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 flush()가 호출됨
2. 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾음
3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보냄
4. 쓰기 지연 저장소의 SQL을 데이터베이스에 보냄
5. 데이터베이스 트랜잭션을 커밋함

### 3. JPQL 쿼리 실행 시 flush() 자동 호출

```java
em.persist(member1);
em.persist(member2);
em.persist(member3);

query = em.createQuery("select m from Membmer m", Member.class);
List<Member> members = query.getResultList();
```
* em.persist()를 통해 엔티티 세개를 영속상태로 만들었으나, 아직 데이터베이스에는 반영되지 않음
* 이러한 상황에서 JPQL을 실행하면 엔티티가 조회되지 않음(= 데이터베이스에 없으니까!)
* 따라서 **쿼리를 실행하기 직전**에 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영하도록 되어있음
