## 연관 관계 주인

```테이블은 외래키 하나로 두 테이블의 연관관계를 관리한다.```
* 이때 엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래키를 관리하면 된다.
* 하지만 양방향으로 매핑하면 서로 참조를 해야하므로 객체의 참조는 둘인데 외래키는 하나인 차이가 발생한다.
* 👉 JPA는 두 객체 연관관계 중 하나를 정하여 테이블의 외래키를 관리하는 이것을 ```연관관계의 주인```이라고 한다.
<br></br>

```java
class Member {
    @ManyToOne
    private Team team;  
}

class Team {
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
}
```

```양방향 연관관계 매핑 시 주인을 정해야한다.```
* 주인을 정한다는 것은 사실 외래키 관리자를 선택하는 것이다.
  * 연관관계의 주인은 테이블에 **외래키가 있는 곳**으로 정해야한다.
  * 회원 테이블의 TEAM_ID 외래키를 만약 Member.team을 주인으로 선택하면 자기 테이블에 있는 외래키를 관리하면 된다.
  * 하지만 팀 엔티티에 있는 Team.members를 주인으로 선택하면 물리적으로 전혀 다른 테이블의 외래키를 관리해야한다.
  * 따라서 항상 '다' 쪽이 외래키를 가지게 된다. 👉 즉 @ManyToOne 에는 mappedBy속성을 설정할 수 없다.
* 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고, 외래키를 관리할 수 있다
* 반면 주인이 아닌쪽은 읽기만 할 수 있다. 👉 주인이 아닌 쪽에 **mappedBy 속성**을 사용하자


## 왜 연관 관계 주인을 설정?

#### 1. 테이블 정의 문제

* DB는 외래키 하나로 양방향이 가능한데, 객체는 단방향 참조 두 개로 양방향을 흉내낸다.
* 하지만 DB 입장에서는 이것이 하나의 연관관계를 양방향으로 흉내낸건지 두 개의 연관관계가 필요한건지 알 수 없다.
  * Member.setTeam()을 해야할지, Team.getMembers().get().setTeam()을 해야할지..
  * 객체 패러다임에서는 두 방식 다 옳지만, 데이터베이스의 패러다임을 적용하려고 존재하는 JPA 입장에서 혼란스러워진다는 것 
* 따라서 Member와 Team 예제에 있어서, 연관관계의 주인을 설정하지 않으면 ddl-auto 설정에서 총 테이블 3개를 생성한다. 
  * 👉 Member, Team, Member_Team 테이블
  * 즉, 연관 관계 주인 개념을 사용하면 양쪽 엔티티 간의 관계를 명확하게 정의하고 테이블 관점에서도 일관성을 유지할 수 있다. 

#### 2. 권한 제한

* mappedBy 속성을 사용하지 않으면 양쪽 엔티티 모두가 연관관계의 주인이 된다.
* 이는 연관관계의 변경이 양쪽 엔티티에 모두 반영되고, 두 개의 업데이트 쿼리가 발생할 수 있다는 의미!
* 즉, 양쪽 엔티티 간의 관계를 수정할 때, member.setTeam()과 team.addMember() 모두 허용하게 되면 양쪽 연관 관계가 변경되어 update 쿼리가 두 번 발생할 수 있다는 것.
* 따라서 mappedBy 속성을 사용하여 한 쪽 엔티티를 연관관계의 주인으로 지정하면, 해당 엔티티만이 연관관계를 수정 권한을 가지게 된다.
* 이로써 불필요한 업데이트 쿼리를 방지하고 동기화 문제를 피할 수 있다.


