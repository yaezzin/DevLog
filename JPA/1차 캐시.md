## 1차 캐시

```영속성 컨텍스트 내부에 존재하는 캐시```

* 엔티티 매니저와 영속성 컨텍스트 사이에서 동작하며, 영속성 컨텍스트 내부에 엔티티를 저장하고, 엔티티를 조회하거나 변경할 때 1차 캐시를 이용
* 1차 캐시는 영속성 컨텍스트 내부에서 관리되기 때문에, 같은 엔티티 매니저를 사용하는 모든 코드에서 공유됨
* 따라서, 같은 엔티티를 여러 번 조회해도 1차 캐시에 존재한다면 데이터베이스에 접근하지 않고 캐시에서 엔티티를 가져오기 때문에 성능상의 이점이 있음
* 트랜잭션이 종료되면 영속성 컨텍스트도 함께 종료되며, 1차 캐시에 저장된 엔티티도 모두 삭제됨


## 더 생각해보기

* ```em.persist()```를 호출하면 해당 엔티티가 영속성 컨텍스트의 1차 캐시에 저장되고, 데이터베이스에 바로 저장되지 않음
  * 대신, **트랜잭션이 커밋되는 시점**에 1차캐시에 저장된 엔티티 변경사항을 데이터베이스에 저장함
  * 트랜잭션을 커밋하기 직전까지 INSERT SQL을 모아둔 이후, 커밋할 때 한번에 데이터베이스에 보낸다 - ```쓰기 지연```
* ```em.find()```를 호출하면 먼저 1차 캐시에서 해당 엔티티를 찾음
  * 만약 1차 캐시에 존재하지 않으면 데이터베이스에서 해당 엔티티를 조회하고 그 결과를 1차 캐시에 저장함
  * 1차 캐시에 이미 존재하는 엔티티인 경우, 새로운 sql 쿼리를 수행하지 않고 1차 캐시에 있는 엔티티를 반환함! -> DB조회보다 빠름!
  * 또한, ```em.find(Member.class, "member1");```을 반복해서 호출해도 영속성 컨텍스트는 같은 엔티티를 반환함
  * 따라서, 1차캐시를 통해 ```성능상의 이점```과 ```엔티티의 동일성```을 보장함!


## JDBC Batch

INSERT 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 소용이 없음. 즉, 커밋 직전에만 데이터베이스에 SQL을 전달하면 됨!  
이 때 **여러 개의 SQL 문을 모아서 한 번에 데이터베이스에 전송하여 실행하는 방식**을 ```JDBC Batch```라고 함
* JDBC에서는 java.sql.Statement 객체와 java.sql.PreparedStatement 객체를 사용하여 배치 처리를 수행할 수 있음
  * Statement 객체는 SQL 문을 실행할 때마다 데이터베이스에 전송하므로, 한 번에 여러 개의 SQL 문을 실행하는 경우 성능이 저하됨
  * 하지만 PreparedStatement 객체를 사용하면, SQL 문을 먼저 데이터베이스에 전송하고, 이후에 해당 SQL 문에 바인딩되는 매개변수 값을 변경하여 반복적으로 실행할 수 있음
* ```hibernate.jdbc.batch.size```로 설정!
